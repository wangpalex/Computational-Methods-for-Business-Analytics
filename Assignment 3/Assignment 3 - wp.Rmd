---
title: "Assignment 3"
author: "Wang Pei"
date: "4/3/2021"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r loading packages, include=FALSE}
library(dplyr)
library(car)
library(lfe)
library(stargazer)
library(evd) # gumbel distribution
library(stats4) # mle
```

```{r Q1.1.1}
df1 = read.csv("hw3q1.csv")
df1$after = as.factor(df1$after)
df1$age = as.factor(df1$age)
df1$received_coupon = as.factor(df1$received_coupon)

age20 = df1[df1['age']=='20-30',]
age30 = df1[df1['age']=='30-40',]
age40 = df1[df1['age']=='40+',]

nrow(age20[age20$after==1,])/nrow(age20)  # 50% each
nrow(age30[age30$after==1,])/nrow(age30)  # 50% each
nrow(age40[age40$after==1,])/nrow(age40)  # 50% each
```

```{r age 20-30}
# Age 20-30
age20 %>% group_by(after, received_coupon) %>% summarise(mean(revenue))

# Treatment effect
# After
after_20 = 12.32244 - 11.78103  # 0.54141
# Before
before_20 = (10.36813 - 10.31286)  # 0.05527
# Average treatment effect
(after_20 + before_20)/2  # 0.29834
# DID
after_20 - before_20  # 0.48614
```

```{r age 30-40}
# Age 30-40
age30 %>% group_by(after, received_coupon) %>% summarize(mean(revenue))
# After
after_30 = 10.32048 - 9.10888  # 1.2116
# Before
before_30 = 8.77142 - 8.45867  # 0.31275
# Average treatment effect
(after_30 + before_30)/2  # 0.762175
# DID
after_30 - before_30  # 0.89885
```

```{r age 40+}
# Age 40+
age40 %>% group_by(after, received_coupon) %>% summarize(mean(revenue))
# After
after_40 = 12.00626 - 10.71556  # 1.9207
# Before
before_40 = 9.34199 - 9.27426  # 0.06773
# Average treatment effect
(after_40 + before_40)/2  # 0.679215
# DID
after_40 - before_40  # 1.22297
```

```{r Q1.1.2}
# Verify with felm
felm1 = felm(revenue ~ received_coupon|after, data=age20)
felm2 = felm(revenue ~ received_coupon|after, data=age30)
felm3 = felm(revenue ~ received_coupon|after, data=age40)
felm4 = felm(revenue ~ after|received_coupon, data=age20)
felm5 = felm(revenue ~ after|received_coupon, data=age30)
felm6 = felm(revenue ~ after|received_coupon, data=age40)

stargazer(felm1,felm2,felm3,felm4,felm5,felm6,
          type="text",omit.stat=c("LL","ser","f"),
          model.numbers=TRUE, model.names = TRUE)

# Use interaction term to find DID 
inter1 = lm(revenue ~ received_coupon*after,data=age20)
inter2 = lm(revenue ~ received_coupon*after,data=age30)
inter3 = lm(revenue ~ received_coupon*after,data=age40)

stargazer(inter1,inter2,inter3,
          type="text",omit.stat=c("LL","ser","f"),
          model.numbers=TRUE, model.names = TRUE)

```

```{r Q2}
data2 = read.csv("hw3q2.csv")
```

```{r Q2.1 mle}
lik = function(beta0,beta1,beta2) {
  # likelihood function
  Pij =
  (data2$choices==0) * 0 +
	(data2$choices==1) * (beta1 + data2$p1 * beta0) +
	(data2$choices==2) * (beta2 + data2$p2 * beta0) -
	log(1+exp(beta1 + data2$p1*beta0)+exp(beta2 + data2$p2*beta0))
  
	return(-sum(Pij))
}

# estimation
mle1 = mle(lik, 
	start = runif(3,-1,0),  # random initialization
	method = "L-BFGS-B", 
	lower = c(-10, -10,-10),
  upper = c(-0.00001, 10, 10))  # beta0, coeff of price, should be negtive

summary(mle1)
#  beta0       beta1        beta2
# -0.07906284  0.66639176  -1.66095162
```

```{r Q2.2}
data2$sales = 1

mkt_share=aggregate(sales~p1+p2+surge_2+choices, data=data2, FUN=sum)
mkt_share$total=ave(mkt_share$sales,by=list(mkt_share$p1,mkt_share$p2,mkt_share$surge_2),FUN=sum)
mkt_share$share=mkt_share$sales/mkt_share$total

iop_dta=subset(mkt_share,choices!=0)#inside options
oop_dta=subset(mkt_share,choices==0)[,c("p1","p2","share")]#outside option
colnames(oop_dta)=c("p1","p2","share0")
lm_dta=merge(oop_dta,iop_dta)#merge inside options with outside option

lm_dta$log_odds=log(lm_dta$share/(lm_dta$share0))
lm_dta$price=(lm_dta$choices==1)*lm_dta$p1+
(lm_dta$choices==2)*lm_dta$p2   #the price for the focal product
lm_dta$product=as.factor(as.character(lm_dta$choices))
lm_dta[1:20,]

logistic_regression=lm(log_odds~price+product,lm_dta)
l2=ivreg(log_odds~price+product|surge_2,lm_dta)
stargazer(logistic_regression,l2, type="text",omit.stat=c("f"))
```

```{r Q2.3.1 one product}
# Is there any price discrimination???

# JustGrab(j=1)


# GrabShare(j=2)

```

```{r Q2.3.2 two products}


```



```{r Q3.1.1 pre-merger}
set.seed(37)
#parameters
beta0=-0.03
beta1=2
beta2=1
beta3=2
N = 10
# global variables
price1=10
price2=10
price3=10

prob_1 = function(price1) {
  exp(beta1+price1*beta0)/
	(1+exp(beta1+price1*beta0)+exp(beta2+price2*beta0)+exp(beta3+price3*beta0))
}
prob_2 = function(price2) {
  exp(beta2+price2*beta0)/
	(1+exp(beta1+price1*beta0)+exp(beta2+price2*beta0)+exp(beta3+price3*beta0))
}
prob_3 = function(price3) {
  exp(beta3+price3*beta0)/
	(1+exp(beta1+price1*beta0)+exp(beta2+price2*beta0)+exp(beta3+price3*beta0))
}

cost = function(s) {
  (s-7)^2 + 50
}

# objective function  of firm 1
profit_1=function(price1){
  produce1 = N*prob_1(price1)
	profit = produce1*price1 - cost(produce1)
	return(-profit)
}

# objective function  of firm 2
profit_2=function(price2){
  produce2 = N*prob_2(price2)
	profit = produce2*price2 - cost(produce2)
	return(-profit)
}

# objective function  of firm 3
profit_3=function(price3){
  produce3 = N*prob_3(price3)
	profit = produce3*price3 - cost(produce3)
	return(-profit)
}

# best response dynamic 
i=0
error=1
Iter=1000
Tol=1e-10
prices = c(1,1,1)
while (i<Iter & error>Tol) {

	i=i+1
	price1=prices[1]
	price2=prices[2]
	price3=prices[3]
	
	prices[1] = optim(c(1), profit_1, method = "L-BFGS-B",
	             lower=c(0),upper=c(Inf))$par
	
	prices[2] = optim(c(1), profit_2, method = "L-BFGS-B", 
	             lower=c(0),upper=c(Inf))$par
	
  prices[3] = optim(c(1), profit_3, method = "L-BFGS-B", 
	             lower=c(0),upper=c(Inf))$par
	
	error=abs(prices[1]-price1)+abs(prices[2]-price2)+abs(prices[3]-price3)
}

price1=prices[1]
price2=prices[2]
price3=prices[3]

c(i, error)
# prices
prices
# sales
c(N*prob_1(price1), N*prob_2(price2), N*prob_3(price3))
# costs
sapply(c(N*prob_1(price1), N*prob_2(price2), N*prob_3(price3)), cost)
# profits
c(-profit_1(c(price1)),-profit_2(c(price2)),-profit_3(c(price3)))

```
The prices of the three products before merge are 42.47629 30.04197 42.47629.
The sales of the three products before merge are 3.313246 1.769962 3.313246 (million).
The cost of the three products before merge is 63.59215 77.35330 63.59215 (million).
The profits of the three products before merge is 77.14225 -24.18015  77.14225.



```{r Q3.1.2 after-merge}
cost_merged = function(s1,s2,lambda1=1,lambda2=1) {
  return(lambda1*cost(s1) + lambda2*cost(s2))
}

profit_merged = function(param) {
  price1=param[1]
  price2=param[2]
  produce1=N*exp(beta1+price1*beta0)/
	(1+exp(beta1+price1*beta0)+exp(beta2+price2*beta0)+exp(beta3+price3*beta0))
  
  produce2=N*exp(beta2+price2*beta0)/
	(1+exp(beta1+price1*beta0)+exp(beta2+price2*beta0)+exp(beta3+price3*beta0))
  
  profit=produce1*price1 + produce2*price2 - cost_merged(produce1,produce2)
  
  return(-profit)
}

price3 = 42.47629
res = optim(c(1,1), profit_merged, method = "L-BFGS-B",
	             lower=c(0,0),upper=c(Inf,Inf))$par

price1 = res[1]
price2 = res[2]
price3 = 42.47629

# prices
c(price1, price2, price3)
# sales
c(N*prob_1(price1), N*prob_2(price2),N*prob_3(price3))
# costs
c(cost_merged(N*prob_1(price1), N*prob_2(price2)), cost(N*prob_3(price3)))
# profits
c(-profit_merged(c(price1, price1)), -profit_3(price3))

```
If firm 3â€™s price is held constant:

- The prices of the three products after merge are 50.38601 46.79862 42.47629.
- The sales of the three products after merge are 3.038511 1.244818 3.852256 (million).

- The cost of the merge and firm 3 after merge is 148.81552  59.90829 (million).
- The profits of the merge and firm 3 after merge is 52.9621 103.7213.

Compared with the pre-merger equilibrium,
the prices of product 1 and 2 increase; sales of product 1 and 2 decreases, sales of product 3 increases; the sum of cost of firm 1 and 2 increases from 63.59215+77.35330 = 140.9454 to 148.81552 and the cost of firm 3 decrease.
The profit of the merge increases from 77.14225-24.18015 = 52.9621 to 62.29782; the profit of firm 3 increases

```{r Q3.2.1}
i = 0
error=1
Iter=1000
Tol=1e-10
prices = c(1,1,1)

while (i < 150 & error > Tol) {
  price1 = prices[1]
  price2 = prices[2]
  price3 = prices[3]
  
  res1 = optim(c(1,1), profit_merged, method = "L-BFGS-B",
	             lower=c(0,0),upper=c(Inf,Inf))$par
  prices[1] = res1[1]
  prices[2] = res1[2]
  prices[3] = optim(c(1), profit_3, method = "L-BFGS-B",
	             lower=c(0),upper=c(Inf))$par
  
  i = i + 1
  error=abs(prices[1]-price1)+abs(prices[2]-price2)+abs(prices[3]-price3)
}

price1=prices[1]
price2=prices[2]
price3=prices[3]

c(i, error)
# prices
prices
# sales
c(N*prob_1(price1),N*prob_2(price2),N*prob_3(price3))
# costs
c(cost_merged(N*prob_1(price1),N*prob_2(price2)), cost(N*prob_3(price3)))
# profits
c(-profit_merged(c(price1, price2)),-profit_3(c(price3)))
```
If firm 3 responds as predicted by a simultaneous move pricing game:

- The prices of the three products after merge are 51.45059 47.79469 45.91185.
- The sales of the three products after merge are 3.100972 1.273021 3.661517(million).
- The cost of the merge and firm 3 after merge is 148.00072  61.14547 (million).
- The profits of the merge and firm 3 after merge is 72.38972 106.96156.

Compared with the answer in part I:
- prices of product 1 and 2 increase and price of product 3 increases.
- sales of product 1 and 2 increase and sales of price 3 decreases.
- cost of merge decreases and the cost of firm 3 increases.
- The profits of the merge increases and the profit of firm 3 decreases
```{r Q3.2.2}
merger_analysis = function(lambda1, lambda2) {
  cost_merged = function(s1,s2) {
    return(lambda1*cost(s1) + lambda2*cost(s2))
  }
  
  profit_merged = function(param) {
    price1=param[1]
    price2=param[2]
    produce1=N*exp(beta1+price1*beta0)/
  	(1+exp(beta1+price1*beta0)+exp(beta2+price2*beta0)+exp(beta3+price3*beta0))
    
    produce2=N*exp(beta2+price2*beta0)/
  	(1+exp(beta1+price1*beta0)+exp(beta2+price2*beta0)+exp(beta3+price3*beta0))
    
    profit=produce1*price1 + produce2*price2 - cost_merged(produce1,produce2)
    
    return(-profit)
  }
  
  profit_3=function(price3){
    produce3 = N*exp(beta3+price3*beta0)/
  	(1+exp(beta1+price1*beta0)+exp(beta2+price2*beta0)+exp(beta3+price3*beta0))
    
  	profit = produce3*price3 - cost(produce3)
  	return(-profit)
  }
  
  i = 0
  error=1
  Iter=1000
  Tol=1e-10
  prices = c(1,1,1)
  
  while (i < 150 & error > Tol) {
    price1 = prices[1]
    price2 = prices[2]
    price3 = prices[3]
    
    res1 = optim(c(1,1), profit_merged, method = "L-BFGS-B",
  	             lower=c(0,0),upper=c(Inf,Inf))$par
    prices[1] = res1[1]
    prices[2] = res1[2]
    prices[3] = optim(c(1), profit_3, method = "L-BFGS-B",
  	             lower=c(0),upper=c(Inf))$par
    
    i = i + 1
    error=abs(prices[1]-price1)+abs(prices[2]-price2)+abs(prices[3]-price3)
  }
  
  price1=prices[1]
  price2=prices[2]
  price3=prices[3]
  
  return (list(
    'prices'= prices, 
    'sales' = c(N*prob_1(price1),N*prob_2(price2),N*prob_3(price3)),
    'costs' = c(cost_merged(N*prob_1(price1),N*prob_2(price2)), cost(N*prob_3(price3))),
    'profits'=c(-profit_merged(c(price1, price2)),-profit_3(c(price3)))
  ))
  
}
#merger_analysis(1,1)['profits']
merger_analysis(1,1)$profits[1]

lambdas = seq(0.5,1.5, by = 0.1)


record = rep(c(0,0,0), 121 )
record = array(record, dim = c(121,3))
#record[1,]


row = 1
for (i in lambdas) {
  for (j in lambdas) {
    profit_aftermerge = merger_analysis(i,j)$profits[1]
    record[row,1] = i
    record[row,2] = j
    record[row,3] = profit_aftermerge
    row = row + 1
  }
  
}
record
```


```{r Q3.2.2}
library("ggplot2")

record1 = as.data.frame(record)

names(record1) = c ("lambda1" , "lambda2", "profit_after_merge")

record1$merge = record1$profit_after_merge >  77.14225-24.18015
record1
ggplot(record1, aes(x=lambda1, y=lambda2)) + geom_point(aes(size=profit_after_merge, color = merge))
```


```{r Q4 original params}
# set up
settings=list(K=3, # number of pack sizes
	n=c(2,6,0), # number of  units in size k, 0 is not buying
	Imax=20, # maximum inventory
	tol=1e-8, # error tolerance for convergence
	iter_max=10000  # maximum  number of iterations
	)

param=list(beta=0.99,
	alpha=4, # price sensitivity
	delta=10, # consumption utility
	c=0.05 # cost for holding inventory
	)

price=list(
	L=2, # number of price levels
	prices=data.frame(price_norm=c(2,5,0),price_prom=c(1.2,3,0)), #K-by-L, normal prices and promotion prices
	prob=c(0.84,0.16) # probability of different price levels.
	)

# fixed point iteration
value_function_iteration=function(settings,param,price){

	value_0=matrix(0,nrow=settings$Imax+1,ncol=price$L) # State vars are inventory and price
	error=settings$tol+1
	iteration=1
	start_time=Sys.time()
	
	while (error>=settings$tol & iteration<= settings$iter_max){
	  # bellman_operator takes in curr_value and updates State
		value=Bellman_operator(value_0,settings,param,price)$value		
		iteration=iteration+1
		error=max(abs(value-value_0))
		value_0=value
	}

	time_elapsed=Sys.time()-start_time
	solution=Bellman_operator(value_0,settings,param,price)

	output=list(time_elapsed,error,iteration,solution)
}

# fixed point operator that updates value function for any 
Bellman_operator=function(value_0,settings,param,price){
  
  # 3 dims: num_Inventory x num_Price x num_Choice
	v_choice=array(0,dim=c(settings$Imax+1,price$L,settings$K))
	value=matrix(0,nrow=settings$Imax+1,ncol=price$L)
	choice=matrix(0,nrow=settings$Imax+1,ncol=price$L)
	inventory=c(0:settings$Imax)
	Ev=value_0%*%price$prob  # expected value

	for (k in 1:(settings$K)){
	  # update inventory
		inventory_new0=inventory+settings$n[k]
		inventory_new=inventory_new0-1
		inventory_new[inventory_new<0]=0
		inventory_new[inventory_new>settings$Imax]=settings$Imax
		# inventory_new = min(settings$Imax, max(0, inventory_new0-1))
		
		# Calculate utility of curr inventory
		utility=param$delta*(inventory_new0>0)-param$c*inventory_new

		for (l in 1:price$L){
			v_choice[,l,k]=utility-param$alpha*price$prices[k,l]+param$beta*Ev[inventory_new+1]
		}		
	}

	for (i in 1:(settings$Imax+1)){
		for (l in 1:price$L){
			value[i,l]=max(v_choice[i,l,])
			choice[i,l]=which.max(v_choice[i,l,])
		}
	}

	output=list(value=value,choice=choice)
	return(output)
}

results=value_function_iteration(settings,param,price)
results
```


```{r Q4.1 Imax=5}
new_settings=list(K=3, # number of pack sizes
	n=c(2,6,0), # number of  units in size k, 0 is not buying
	Imax=5, # maximum inventory
	tol=1e-8, # error tolerance for convergence
	iter_max=10000  # maximum  number of iterations
	)

results=value_function_iteration(new_settings, param, price)
results
```


Observation:

When max inventory = 5, all of the maximum expected sum of discounted utility (abbreviated as utility value below) is less than those when inventory = 20. 

As for the choices, for max inventory = 20, it is more likely for the customer to opt for choice 3 (not buying) when current stock is higher than a threshold; secondly, for max inventory = 20, the optimal strategy suggests not to opt for choice 1 (small package).


Explanation: 

Generally, the utility value of choice 2 (large package) is higher than that of choice 1 (small package). When max inventory = 20, the customer never opt for choice 1, but when max inventory = 5, the customer seldom have chances to opt for choice 2, which might be the reason that the later has lower utility value at convergence. 

```{r Q4.2 discount=0.5}
new_param_1=list(beta=0.5,
	alpha=4, # price sensitivity
	delta=10, # consumption utility
	c=0.05 # cost for holding inventory
	)
results=value_function_iteration(settings, new_param_1, price)
results
```



```{r Q4.3.1 price coeff larger}
new_param_2=list(beta=0.99,
	alpha=12, # price sensitivity: 4 -> 6
	delta=10, # consumption utility
	c=0.05 # cost for holding inventory
	)
results=value_function_iteration(settings, new_param_2, price)
results
```

```{r Q4.3.2 price coeff smaller}
new_param_3=list(beta=0.99,
	alpha=2, # price sensitivity: 4 -> 2
	delta=10, # consumption utility
	c=0.05 # cost for holding inventory
	)
results=value_function_iteration(settings, new_param_3, price)
results
```


```{r Q4.4}
new_price=list(
	L=3, # number of price levels
	prices=data.frame(price_norm=c(2,5,0),discount_1=c(1.4,3.5,0),discount_2=c(0.8, 2, 0)),
	# discount_1: 70%, discount_2: 40%
	#K-by-L, normal prices and promotion prices
	prob=c(0.8, 0.1, 0.1) # probability of different price levels.
	)

results=value_function_iteration(settings, param, new_price)
results
```
